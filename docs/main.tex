\documentclass[paper=a4,fontsize=12pt,titlepage]{scrartcl}
%-----------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
%-----------------------------------------------
\usepackage{amsmath,amssymb,amsthm,mathtools,stmaryrd}
%-----------------------------------------------
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz, pgf}
\usepackage{float}
\usepackage{adjustbox}

\usetikzlibrary{arrows,shapes,positioning}
%-----------------------------------------------
\usepackage[ruled,lined]{algorithm2e}
\usepackage{listings}
%-----------------------------------------------
\usepackage[
	colorlinks=true,
	breaklinks=true,
	linkcolor=blue,
	filecolor=magenta,
	urlcolor=cyan,
	pdftitle={Project},
	pdfsubject={Project}
]{hyperref}
%-----------------------------------------------
\usepackage{typearea}

\KOMAoptions{
	DIV=12,
	BCOR=0mm,
	abstract=true,
	pagesize=auto
}
\recalctypearea
%-----------------------------------------------
\newenvironment{AThreeLandscape}{%
	\clearpage
	\KOMAoptions{paper=a3, paper=landscape}%
	\recalctypearea%
	\thispagestyle{plain}%
}{%
	\clearpage
	\KOMAoptions{paper=a4, paper=portrait}%
	\recalctypearea%
}
%-----------------------------------------------
\newenvironment{AFourLandscape}{%
	\clearpage
	\KOMAoptions{paper=a4, paper=landscape}%
	\recalctypearea%
	\thispagestyle{plain}%
}{%
	\clearpage
	\KOMAoptions{paper=a4, paper=portrait}%
	\recalctypearea%
}
%-----------------------------------------------
\newtheorem{theorem}{Théorème}
\newtheorem{axiom}{Axiome}

\theoremstyle{definition}
\newtheorem{mydef}{Définition}
\newtheorem{mycor}{Corollaire}

\theoremstyle{remark}
\newtheorem{myrem}{Remarque}

\theoremstyle{plain}
\newtheorem{myprop}{Proposition}

\DeclareMathOperator{\Ima}{Im}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Card}{Card}
\DeclareMathOperator{\Sp}{Sp}
\DeclareMathOperator{\Inf}{Inf}
\DeclareMathOperator{\Vect}{Vect}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\Mat}{\mathcal{M}at}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%

\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother
%-----------------------------------------------
\sloppy
\hyphenpenalty=10000
%-----------------------------------------------
\title{
	\Huge Rasende Roboter\\
	\Large Projet IA41
}

\author{
	Noa \textsc{FOUICH}\\
	Corentin \textsc{HAUTEFAYE}\\
	William \textsc{LE GALLOU}\\
	Kenneth \textsc{SOARES}
}

\date{Janvier 2026}
%-----------------------------------------------
\begin{document}
	
	\maketitle
	
	\renewcommand*{\abstractname}{Introduction}
	\begin{abstract}
		\thispagestyle{plain}
		Dans le cadre de l'UE IA41 (\textit{Semestre A25}), nous avons réalisé une implémentation du jeu de décision \textit{Rasende Roboter}. L'objectif de ce projet est
		de programmer un système capable de fournir une solution aux configurations proposées, autrement dit de permettre à un utilisateur de jouer des parties contre l'ordinateur.
	\end{abstract}
	
	\tableofcontents
	\clearpage
%-----------------------------------------------
	\section{Présentation générale}
	\subsection{Rappel de l'énoncé du sujet}
	
	\textbf{INSERT TEXT HERE}
	
	\subsection{Conventions}
	
	\textbf{INSERT TEXT HERE}
	
	\subsection{Outils utilisés}
	
	Pour réaliser ce projet, les outils suivants ont été utilisés:
	\begin{itemize}
		\item \textbf{Python 3} 
		\item \textbf{PyGame} pour l'interface graphique
		\item \textbf{Git} et \textbf{GitHub} pour le contrôle des versions
		\item \textbf{\LaTeX} pour la rédaction du rapport
	\end{itemize}
%-----------------------------------------------
	\newpage
	\section{Spécification du problème}
	
	Dans cette section, on cherche à généraliser et formaliser une partie de jeu. 
	
	\subsection{Notations}
	
	Soit $k\in\mathbb{N}\backslash\{0;1\}$. Soit $n\in\mathbb{N}$ tel que $n\ge k+1$. Afin de représenter le plateau de jeu, on définit les notations suivantes:
	\begin{itemize}
		\item $B=\llbracket 1;n\rrbracket^2$ une grille de $n\times n$ cases.
		\item Pour tout $i\in\llbracket 1;k\rrbracket, r_i=(x_i,y_i)\in B$ représente le $i$-ème robot.
		\item $C=\left\{\{(x,y),(x',y')\}\;\Big|\; \left\{\begin{array}{ll}
					(x,y) &\in B \\
					(x',y') &\in B \\
					\abs{x-x'}+\abs{y-y'} &=1
				\end{array}\right.\right\}$ l'ensemble des collisions entre les cases de $B$, deux à deux.
		\item $D=\left\{(1,0),(-1,0),(0,1),(0,-1)\right\}$ l'ensemble des directions cardinales.
	\end{itemize}
	
	\subsection{Espace d'états}
	
	\begin{mydef}
		On définit un \textit{état du jeu} par tout $k$-uplet de $B$.
		L'ensemble de tous les états possibles, noté $\mathcal{S}$, correspond à l'ensemble des positions occupées par les $k$ robots, d'où $\mathcal{S}=B^k$.
	\end{mydef}
	
	Il est important de noter que de ce fait, on obtient $\Card(\mathcal{S})=n^{2k}$. Or, la définition proposée n'impose pas à un état d'être valide. En effet, il est impossible que deux robots occupent la même case, d'où:
	
	\begin{mydef}
		On définit \textit{l'ensemble des états valides}, ou \textit{espace d'états}, et on note $\mathcal{S}_v=\left\{(r_1,\ldots,r_k)\in B^k\;\Big|\;\forall(i,j)\in\llbracket 1;k\rrbracket^2, (i\ne j)\implies (r_i\ne r_j)\right\}$. Un élément de $\mathcal{S}_v$ est dit \textit{valide}.
	\end{mydef}
	
	L'inclusion $\mathcal{S}_v\subset\mathcal{S}$ est ainsi triviale.
	
	\begin{myprop} \label{prop:card}
		On a $\Card\left(\mathcal{S}_v\right)=\frac{(n^2)!}{(n^2-k)!}$.
	\end{myprop}
	
	\begin{proof}
		On cherche le nombre de $k$-uplets injectifs $(r_1,\ldots,r_k):\llbracket 1;k\rrbracket\rightarrow B$. Formellement, chaque fonction $f:\llbracket 1;k\rrbracket\rightarrow B$ qui est injective correspond à un état valide. Or, le nombre de fonctions injectives de $\llbracket 1;k\rrbracket$ dans $B$ est exactement le nombre d'arrangements de $k$ parmi $n^2$ éléments.
		
		D'où, la conclusion.
	\end{proof}
	
	\begin{myrem}
		On obtient ainsi le fait que l'espace d'états croît très rapidement en fonction de $n$ et $k$.
	\end{myrem}
	
	\subsection{Fonction de transition}
	
	\begin{mydef}
		On définit la \textit{fonction de transition} pour passer d'un état valide à un autre, d'où:
		
		\[
			\begin{array}{lll}
				\delta :& \mathcal{S}_v\times\llbracket 1;k\rrbracket\times D &\rightarrow\mathcal{S}_v \\
				&((r_1,\ldots,r_k),i,d)&\mapsto (r_1,\ldots,r_i+dt,\ldots,r_k)
			\end{array}
		\]
		
		avec $t=\min \Big\{ s \in \mathbb{N}^* \;\Big|\; \begin{array}{ll}
			&\exists j \in\llbracket 1;k\rrbracket,\; r_i + d(s+1) = r_j \\
			\text{ou} &\{ r_i + ds, r_i + d(s+1) \} \in C 
		\end{array}\Big\}$
	\end{mydef}
	
	\begin{myrem}
		Comme pour le passage d'un état à un autre, il est facile de trouver les variables $i$ et $d$, il est recevable de simplifier l'écriture de $\delta(S,i,d)$ par $\delta(S)$.
	\end{myrem}
	
	\begin{myprop} \label{prop:delta}
		À partir d'un état, $\delta$ peut engendrer $\Card(D)\times k$ états valides.
	\end{myprop}
	
	\begin{mydef}
		Soit $t\in\llbracket 1;k\rrbracket$ et $S_0=(r_1,\ldots,r_k)\in\mathcal{S}_v$ l'état initial. Soit $g\in B$ une case. On dit que $g$ est \textit{atteignable} depuis $S_0$ par $r_t$ \underline{ssi} il existe une suite finie de $m+1\in\mathbb{N}$ états $(S_i)_{i\in\llbracket 0;m\rrbracket}$ telle que pour tout $i\in\llbracket 1;m\rrbracket, \delta(S_{i-1})=S_i$ et $(S_m)_t=g$ où $(S_m)_t$ désigne la position du $t$-ième robot dans l'état considéré.
	\end{mydef}
	
	On définit ainsi l'ensemble $G$ des cases objectifs jouables par:
	\[
		G=\left\{g\in B \;|\;\exists m\in\mathbb{N}, \exists (S_i)_{i\in\llbracket 0;m\rrbracket}, \left\{\begin{array}{ll}
			\forall i\in\llbracket 1;m\rrbracket, &\delta(S_{i-1})=S_i\\
			(S_m)_t=g
		\end{array}\right.\right\}
	\]
	
	\begin{mydef}
		On appelle \textit{configuration de jeu} tout sextuplet
		\[
		(k, n, t, C, R, g)
		\]
		où :
		\begin{itemize}
			\item $k$ est le nombre de robots,
			\item $n$ est la taille du plateau,
			\item $t\in\llbracket 1;k\rrbracket$ est l'indice du robot cible,
			\item $R$ est l'ensemble des positions initiales des robots,
			\item $C$ est l'ensemble des obstacles entre cases adjacentes,
			\item $g \in G$ est la case objectif du robot cible.
		\end{itemize}
	\end{mydef}
	
	\begin{mydef}
		Soit $(t,g,R)\in \llbracket 1;k\rrbracket\times G\times B^k$. Soit $\mathcal{C}=(k,n,t,C,R,g)$ une configuration de jeu et $S\in\mathcal{S}_v$. $S$ est dit \textit{terminal} \underline{ssi} $(S)_t=g$. On note l'ensemble des états terminaux par $\mathcal{T}$.
	\end{mydef}
	
	Il est ainsi clair que $\mathcal{T}\subseteq\mathcal{S}_v$.	
	
%-----------------------------------------------
	\newpage
	\section{Analyse du problème}
	
	À partir de la formalisation précédente, nous étudions maintenant la nature du problème de recherche induit, ses contraintes en termes de calculs, ainsi que les approches algorithmiques envisageables pour le résoudre.
	
	\subsection{Nature et caractéristiques du problème}
	
	Le jeu \textit{Rasende Roboter} est modélisable par un problème de recherche dans un espace d’états, certes fini mais très vaste.
	Chaque état valide correspond à un sommet du graphe orienté engendré, et chaque application de la fonction de transition $\delta$ définit alors une arête entre deux nœuds.
	
	L’objectif est de trouver pour une configuration de jeu donnée, une suite de transitions menant d’un état initial $S_0\in\mathcal{S}_v$ à un état terminal $S_G \in \mathcal{T}$, tout en minimisant le nombre de coups effectués par des déplacements de robots. En sus d'être un problème de décision, il s'agit également d'un problème d'optimisation.
	
	À partir de ce paragraphe, on considère $n=16$ et $k=4$. Les autres variables restent quantifiées de la même manière.
	
	\subsection{Contraintes et difficultés}
	D'après la proposition~\ref{prop:card}, l’espace d’états $\mathcal{S}_v$ est de cardinal $\frac{256!}{252!}=253\times 254\times 255 \times 256 \approx 4,2\times 10^9$, d'où un nombre d’états presque impossible à gérer.
	
	De plus, le facteur de branchement est important: à chaque état, il est possible de déplacer chacun des $k$ robots dans les quatre directions cardinales $D$, tant que le déplacement est valide. Ainsi, chaque nœud a au plus $16$ enfants (\textit{d'après la proposition~\ref{prop:delta}}). 
	
	Ces caractéristiques rendent toute exploration exhaustive de l’espace d’états rapidement intractable sans stratégie de recherche adaptée.
	
	\subsection{Graphe implicite}
	Le graphe n’est jamais construit explicitement en raison de sa taille combinatoire. Les successeurs d’un état sont générés dynamiquement à l’aide de la fonction de transition $\delta$ lors de l’exploration. C'est pour cela que l'on parle de \textit{graphe implicite}.
	
	Ce dernier est ainsi:
	\begin{itemize}
		\item Fini
		\item Orienté
		\item Non pondéré (\textit{on considère qu'une transition a un coût unitaire})
		\item Fortement connexe par composantes
		\item De facteur de branchement borné par $\Card(D)\times k$ (\textit{ici par $16$})
	\end{itemize}
	
	
	\textbf{EXEMPLE ICI}
	
	\subsection{Approches algorithmiques}
	La résolution du problème peut être abordée par des algorithmes de parcours	de graphes orientés. On distingue ainsi deux familles:
	
	\subsubsection{Recherche non informée}
	Les algorithmes de recherche non informée, tels que le parcours en largeur (\textit{BFS}), explorent l’espace d’états sans utiliser d’information spécifique au problème. BFS garantit la découverte d’une solution optimale en nombre de coups, au prix d’une consommation mémoire importante.
	
	\subsubsection{Recherche informée}
	Les algorithmes de recherche informée, comme A*, exploitent une heuristique
	estimant la distance restante jusqu’à l’objectif. Cette approche permet de réduire considérablement le nombre d’états explorés, tout en conservant l’optimalité pourvu que l'heuristique soit admissible.
	
	\subsubsection{Critères de choix d'une approche}
	
	Le choix de l’algorithme dépend essentiellement de:
	\begin{itemize}
		\item La taille de l’espace d’états
		\item L'optimalité de la solution à trouver
		\item Des complexités spatiales et temporelles
	\end{itemize}

%-----------------------------------------------
	\newpage
	\section{Traitement du problème}
	\subsection{Algorithmes étudiés}
	\subsubsection{Parcours en largeur}
	
	\begin{myprop} \label{prop:opti}
		Soit $G$ un graphe. Un parcours en largeur est \textit{optimal} \underline{ssi}
		\begin{enumerate}
			\item $G$ est non pondéré
			\item Chaque transition correspond à un coût unitaire
			\item $G$ est exploré sans revisiter les états déjà rencontrés
		\end{enumerate}
	\end{myprop}
	
	Notons que les hypothèses énoncées dans la proposition~\ref{prop:opti} sont rencontrées pour ce problème.
	
	\begin{myprop}
		Le parcours en largeur trouve une solution optimale en nombre de coups lorsqu’elle existe.
	\end{myprop}
	
	\begin{proof}
		Considérons le graphe orienté implicite $G=(\mathcal{S}_v,E)$, où pour tout $(S,S')\in\mathcal{S}_v^2,\;(S,S')\in E \iff S'=\delta(S)$ pour une action valide.
		
		Soit $S_0\in\mathcal{S}_v$ l'état initial. Le parcours en largeur explore les sommets de $G$ par couches successives, où la couche $d\in\mathbb{N}^*$ contient exactement les états atteignables depuis $S_0$ par une suite de $d$ transitions.
		
		Soit $S_G\in\mathcal{T}$ un état terminal tel que la distance minimale entre $S_0$ et $S_G$ soit $d^\star$. Par construction, BFS explore tous les états à distance strictement inférieure
		à $d^\star$ avant d’explorer ceux à distance $d^\star$.
		
		Ainsi, lors de la première rencontre d’un état terminal $S_G$, le chemin construit comporte exactement $d^\star$ transitions, ce qui est minimal. 
		
		Par conséquent, BFS retourne une solution optimale en nombre de coups.
	\end{proof}
	
	
	\subsubsection{Algorithme A*}
	
	\begin{myprop}
		A* est \textit{optimal} \underline{ssi}	
		\begin{enumerate}
			\item Tous les coûts d'arêtes sont positifs
			\item L'heuristique $h$ est \textit{admissible}, i.e $\forall S\in\mathcal{S }_v, h(S)\le h^\star (S)$ où $h^\star$ représente le coût réel pour aller à un état
		\end{enumerate}
	\end{myprop}
	
	\begin{myprop}
		Si l’heuristique $h$ est admissible, alors l’algorithme A* retourne une
		solution optimale en nombre de coups lorsqu’elle existe.
	\end{myprop}
	
	\begin{proof}
		Soit $S_0\in\mathcal{S}_v$ l'état initial. Soit $S_G\in\mathcal{T}$ un état terminal atteignable depuis $S_0$, et soit $c^\star$ le coût minimal pour aller de $S_0$ à $S_G$.
		
		Soit $(g,h)\in\left(\mathcal{F}(\mathcal{S}_v,\mathbb{N})\right)^2$, avec pour tout $S\in\mathcal{S}_v$, $g(S)$ et $h(S)$ représente respectivement le coût exact de $S_0$ vers $S$ et l'heuristique évaluée en $S$, supposée admissible. On peut ainsi définir la fonction $f:\mathcal{S}_v\to\mathbb{N}$ telle que $f=g+h$. 
		
		Pour tout état $S\in\mathcal{S}_v$, on a donc :
		\[
		f(S) \le g(S) + h^\star(S)
		\]
		
		Supposons par l’absurde que A* retourne une solution $S\in\mathcal{S}_v$ de coût $c\in\mathbb{N}$ tel que $c > c^\star$ avant d’explorer un chemin optimal.
		Alors, il existe un état $S'\in\mathcal{S}_v$ sur un chemin optimal tel que
		\[
		g(S') + h(S') \le g(S') + h^\star(S') < c
		\]
		
		D'où:
		\[
		f(S') \le c^\star < c
		\]
		ce qui implique que $S'$ aurait dû être extrait de la file de priorité
		avant $S$, ce qui est absurde.
		
		Ainsi, le premier état terminal extrait par A* correspond nécessairement
		à un chemin de coût minimal.
	\end{proof}
	
	\subsubsection{Heuristiques étudiées}
	
	
	\subsection{Organisation du programme}
%-----------------------------------------------
	\newpage
	\section{Études de cas \& Résultats}
	\subsection{Description des situations testées}
	\subsection{Résultats obtenus}
	\subsection{Interprétation des résultats}
%-----------------------------------------------	
	\newpage	
	\section{Retour d'expérience}
	\subsection{Organisation}
	\subsection{Difficultés rencontrées}
	\subsection{Suggestions d'amélioration}
%-----------------------------------------------
	\newpage	
	\section{Conclusion}
\end{document}
